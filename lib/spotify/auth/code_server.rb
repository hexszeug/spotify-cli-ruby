# frozen_string_literal: true

require 'webrick'

module Spotify
  module Auth
    module CodeServer
      # raised by CodeServer.start when the system call to open the socket fails
      class OpenServerError < Auth::LoginError
        attr_reader :system_call_error

        def initialize(system_call_error)
          super
          @system_call_error = system_call_error
        end
      end

      # raised when authorize endpoint denies request for authorization code
      # for possible error_str see https://www.rfc-editor.org/rfc/rfc6749#section-4.1.2.1
      class CodeDeniedError < Auth::LoginError
        attr_reader :error_str

        def initialize(error_str)
          super()
          @error_str = error_str
        end
      end

      class << self
        include WEBrick

        HTTP_SERVER_CONFIG = Config::HTTP.update(Logger: BasicLog.new(nil, 0))
        HOST = URI(Spotify::Auth::REDIRECT_URL)

        # returns:
        # - Proc (to cancel async execution)
        #
        # yields:
        # - String (code)
        #
        # raises:
        # - OpenCodeServerError
        #
        # yield-raises:
        # - CodeDeniedError
        # - every error raised in &block
        #
        # TODO: return promise which may register a error handler
        def start(state, &block)
          return unless block_given?

          @state = state
          @callback = block
          return if @server

          begin
            @server = TCPServer.new(HOST.hostname, HOST.port)
          rescue SystemCallError => e
            raise OpenServerError, e
          end
          Thread.new { server_loop }
          proc { stop }
        end

        def stop
          return unless @server

          @server.close
          @state = nil
          @callback = nil
        end

        private

        def server_loop
          Thread.current.name = 'code-server/loop'
          begin
            while @server && !@server.closed?
              Thread.new(@server.accept) do |socket|
                handle_connection socket
                socket.close
              end
            end
          rescue IOError
            @server&.close
            @server = nil
          end
        end

        def handle_connection(socket)
          Thread.current.name =
            "code-server/client(#{socket.peeraddr[2]}:#{socket.peeraddr[1]})"
          req = HTTPRequest.new HTTP_SERVER_CONFIG
          res = HTTPResponse.new HTTP_SERVER_CONFIG
          begin
            req.parse socket
          rescue HTTPStatus::BadRequest
            generate_response res, MalformedRequest.new
          rescue HTTPStatus::EOFError
            return # socket was probably closed -> don't respond
          else
            handle_request req, res
          end

          res.keep_alive = false
          res.setup_header
          res.header.delete 'server' # is generated by HTTPResponse#setup_header
          begin
            res.send_header socket
            res.send_body socket
          rescue StandardError
            # sending response failed -> ignore it
          end
        end

        def handle_request(req, res)
          unless @state && req.path == HOST.path
            generate_response(res, NoContent.new)
            return
          end
          if req.query['state'] != @state
            generate_response(res, BadState.new(req.query['state']))
            return
          end
          unless req.query.key?('code')
            on_code_denied(res, req.query['error'])
            return
          end
          on_code_received(res, req.query['code'])
        end

        def on_code_denied(res, error_str)
          callback = @callback
          CodeServer.stop
          report_error(res, callback, CodeDeniedError.new(error_str))
        end

        def on_code_received(res, code)
          callback = @callback
          CodeServer.stop
          old_thread_name = Thread.current.name
          Thread.current.name = 'code-server/return'
          begin
            callback.call code
          rescue StandardError => e
            Thread.current.name = old_thread_name
            report_error(res, callback, e)
          else
            generate_response res
          end
        end

        def report_error(res, callback, error)
          Thread.new do
            Thread.current.name = 'code-server/return/error'
            callback.call error
          end
          generate_response res, error
        end

        def generate_response(res, error = nil)
          # TODO: generate prettier response pages
          res.status = HTTPStatus::RC_BAD_REQUEST # default
          case error
          when nil
            res.status = HTTPStatus::RC_OK
            res.body = 'success'
          when MalformedRequest
            res.body = 'malformed request'
          when NoContent
            res.status = HTTPStatus::RC_NO_CONTENT
          when BadState
            res.body =
              error.state? ? "wrong state '#{error.state}'" : 'missing state'
          when CodeDeniedError
            # TODO: prettier response: parse error_str from https://www.rfc-editor.org/rfc/rfc6749#section-4.1.2.1
            res.body = "access denied. #{error.error_str}"
          when Auth::TokenFetcher::TokenDeniedError
            # TODO. prettier response: parse error_str form https://www.rfc-editor.org/rfc/rfc6749#section-5.2
            res.body = "token denied. #{error.error_str}"
          else
            res.status = HTTPStatus::RC_INTERNAL_SERVER_ERROR
            res.body = "internal error. (#{error.class})"
          end
        end

        # superclass bundling all internal server errors
        # that only occur internally
        class InternalError < StandardError
        end

        # internal error
        # used for malformed http requests
        class MalformedRequest < InternalError
        end

        # internal error
        # used for other paths then /callback/
        # or when server isn't listening for requests
        class NoContent < InternalError
        end

        # internal error
        # used for wrong or missing state
        class BadState < InternalError
          attr_reader :state

          def initialize(state)
            super()
            @state = state
          end

          def state?
            @state ? true : false
          end
        end
      end
    end
  end
end
